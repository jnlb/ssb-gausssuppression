% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SuppressLinkedTables.R
\name{SuppressLinkedTables}
\alias{SuppressLinkedTables}
\title{Consistent Suppression of Linked Tables}
\usage{
SuppressLinkedTables(
  fun,
  data = NULL,
  ...,
  withinArg = NULL,
  linkedGauss,
  recordAware = TRUE,
  iterBackTracking = Inf,
  whenEmptyUnsuppressed = NULL
)
}
\arguments{
\item{fun}{A function: \code{\link{GaussSuppressionFromData}} or one of its wrappers such as
\code{\link{SuppressSmallCounts}} and \code{\link{SuppressDominantCells}}.}

\item{data}{The \code{data} argument to \code{fun}. When NULL \code{data} must be included in  \code{withinArg}.}

\item{...}{Arguments to \code{fun} that are kept constant.}

\item{withinArg}{A list of named lists. Arguments to \code{fun} that are not kept constant.}

\item{linkedGauss}{Specifies the strategy for protecting linked tables. Possible values are:
\itemize{
\item \code{"consistent"} (default): All linked tables are protected by a single call to \code{GaussSuppression()}.
The algorithm internally constructs a block diagonal model matrix and handles common cells
consistently across tables.
\item \code{"local"}: Each table is protected independently by a separate call to \code{GaussSuppression()}.
\item \code{"back-tracking"}: Iterative approach where each table is protected via \code{GaussSuppression()},
and primary suppressions are adjusted based on secondary suppressions from other tables across
iterations.
\item \code{"local-bdiag"}: Produces the same result as \code{"local"}, but uses a single call to
\code{GaussSuppression()} with a block diagonal matrix. It does not apply the linked-table methodology.
}}

\item{recordAware}{If \code{TRUE} (default), the suppression procedure will ensure consistency
across cells that aggregate the same underlying records,
even when their variable combinations differ.
When \code{TRUE}, \code{data} cannot be included in  \code{withinArg}.}

\item{iterBackTracking}{Maximum number of back-tracking iterations.}

\item{whenEmptyUnsuppressed}{Parameter to \code{\link[SSBtools]{GaussSuppression}}.}
}
\value{
List of data frames
}
\description{
Provides alternatives to global suppression for linked tables through
methods that may reduce the computational burden.
}
\examples{
 
#### Similar to parameter_linkedGauss example
# Trick "sector4 - sector4" and "geo - geo" to ensure same names in output 
output <- SuppressLinkedTables(data = SSBtoolsData("magnitude1"),
                 fun = SuppressDominantCells, 
                 withinArg = list(list(formula = ~(geo + eu) * sector2 + sector4 - sector4), 
                                  list(formula = ~eu:sector4 - 1 + geo - geo), 
                                  list(formula = ~geo + eu + sector4 - 1)), 
                 dominanceVar  = "value", 
                 pPercent = 10, 
                 contributorVar = "company",
                 singletonMethod = "none", 
                 linkedGauss = "consistent") 

####  Similar to LazyLinkedTables example:
z1 <- SSBtoolsData("z1")
z2 <- SSBtoolsData("z2")
z2b <- z2[3:5]  # As in ChainedSuppression example 
names(z2b)[1] <- "region" 
# As 'f' and 'e' in ChainedSuppression example. 
# 'A' 'annet'/'arbeid' suppressed in b[[1]], since suppressed in b[[3]].
b <- SuppressLinkedTables(fun = SuppressSmallCounts,
     linkedGauss = "back-tracking",  
     singletonMethod = "none",  # since For now singletonMethod must be none ... 
     recordAware = FALSE,
     withinArg = list(
       list(data = z1, dimVar = 1:2, freqVar = 3, maxN = 5), 
       list(data = z2b, dimVar = 1:2, freqVar = 3, maxN = 5), 
       list(data = z2, dimVar = 1:4, freqVar = 5, maxN = 1)))
}
