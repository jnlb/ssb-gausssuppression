

#' Dominance `(n,k)` rule for magnitude tables
#' 
#' Supports application of multiple values for `n` and `k`. The function works on magnitude tables containing negative cell values by calculating contribution based on absolute values.
#' 
#' This methodn only supports suppressing a single numeric variable.
#' @param data the dataset
#' @param x ModelMatrix generated by parent function
#' @param crossTable crossTable generated by parent function
#' @param numVar vector containing numeric values in the data set
#' @param n parameter `n` in dominance rule. 
#' @param k parameter `k` in dominance rule.
#' @param protectZeros parameter determining whether cells with value 0 should be suppressed.
#' @param charVar Variable in data holding grouping information. Dominance will be calculated after aggregation within these groups.
#' @param ... unused parameters
#' @return logical vector that is `TRUE` in positions corresponding to cells breaching the dominance rules.
#' @export
#'
#' @author Daniel Lupp 
#' 
DominanceRule <- function(data, x, crossTable, numVar, n, k,
                          protectZeros = FALSE, charVar, sWeightVar = NULL, ...) {
  if (length(n) != length(k))
    stop("You must provide an equal number of inputs for n and k.")
  if (is.null(numVar))
    stop("You must provide a numeric variable numVar to use the dominance rule.")
  if (length(numVar) > 1){
    warning("Multiple numVar were supplied, only the first is suppressed.")
    numVar <- numVar[1]
  }
  if (!protectZeros)
    cat("Zeroes are not primary suppressed.\n")
  else
    cat("Zeroes are primary suppressed.\n")

  
  abs_num <- as.data.frame(as.matrix(crossprod(x, as.matrix(abs(data[, numVar, drop = FALSE])))))
  abs_inputnum <- abs(data[[numVar]])
  
  if (length(charVar)) {
    if (length(charVar) == 1) {
      charVar_groups <- data[[charVar]]
      sweight <- NULL
    } else {
      stop("Only single charVar implemented")
    }
  } else {
    charVar_groups <- NULL
    if (is.null(sWeightVar)) 
      sweight <- as.matrix(rep(1, nrow(data)))
    else 
      sweight <- as.matrix(data[, sWeightVar, drop = FALSE])
  }
  
  primary <- mapply(function (a,b) FindDominantCells(x, abs_inputnum, abs_num, a,b, charVar_groups = charVar_groups, samplingWeight = sweight),
                    n,k)

  dominant <- apply(primary, 1, function (x) Reduce(`|`, x))
  if (!protectZeros) 
    return(dominant)
  dominant | (abs_num == 0)
}

#' Method for finding dominant cells according to (possibly multiple) n,k 
#' dominance rules.
#' 
#' Supports functionality for grouping contributions according to holding
#' variables, as well as calculating dominance in surveys with a given sampling
#' weight. The method implemented for calculating upsampled contributions is the
#' same as in tauArgus, and is described in the book "Statistical Disclosure 
#' Control" (Hundepool et al 2012), p. 151.
#'
#' @param x model matrix describing relationship between input and published
#' cells
#' @param inputnum vector of numeric contributions for each of the input records
#' @param num vector of numeric values for each of the published cells
#' @param n vector of integers describing n parameters in n,k rules. Must be
#' same length as `k` parameter.
#' @param k vector of numeric values describing k parameters in n,k rules, where
#' percentages are described as numbers less than 100. Must be same length as
#' `n` parameter.
#' @param charVar_groups vector describing which input records should be grouped
#' @param samplingWeight vector of sampling weights associated to input records
#'
#' @return logical vector describing which publish-cells need to be suppressed.
#' @export
#'
#' @examples
FindDominantCells <- function(x, inputnum, num, n, k, charVar_groups, samplingWeight) {
  if (is.null(samplingWeight)) {
  # without sampling weight, calculate dominance directly from numerical values
    max_cont <- MaxContribution(x, inputnum, n = n, groups = charVar_groups)
    max_cont[is.na(max_cont)] <- 0
    return(as.vector(num > 0 & rowSums(max_cont) > num*k/100))
  } else {
  # with sampling weights, need to weight the numerical contributions
    max_cont_index <- MaxContribution(x, inputnum, n = n, groups = charVar_groups, index = TRUE)
    cont_weights <- apply(max_cont_index, 2, function(t) samplingWeight[t])
    # last_index_t describes cumulative sum of contributing weights, used to
    # calculate which of the contributions need to be considered
    if (n == 1)
      last_index_t <- cont_weights
    else
      last_index_t <- t(apply(cont_weights, 1, function(t) cumsum(t)))
    # index of last contribution to be added to upsampled contribution
    last_index <- apply(last_index_t, 1,
                        function(t) {
                          ind <- which(t >= n)[1]
                          ifelse(!length(ind), sum(!is.na(t)), ind)
                        })
    # only keep the first n contributors (counting weights) and ensure 
    # rowSums(cont_weights) == n
    for (ind in seq(length(last_index))) {
      cont_weights[ind, last_index[ind]] <- ifelse(last_index[ind] == 1,
                                                   n,
                                                   n - last_index_t[ind, last_index[ind] - 1])
      cont_weights[ind, 1:ncol(cont_weights) > last_index[ind]] <- 0
    }
    # sampling weights multiplied with contributions and added up
    max_cont <- apply(max_cont_index, 2, function(t) ifelse(is.na(t), 0, inputnum[t]))
    ncontributions <- rowSums(max_cont * cont_weights)
    return(as.vector(num > 0 & ncontributions > num*k/100))
  }
}
