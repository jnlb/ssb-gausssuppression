



#' `primary` and `forced` from suppressed data
#' 
#' Function for \code{\link{GaussSuppressionFromData}}
#' 
#' `ForcedFromSuppressedData`  uses `forcedData = TRUE` and hence a  vector to be use as forced is generated. 
#' `NotPrimaryFromSuppressedData` is similar, but `TRUE` elements are replaced by `NA`'s. 
#' Hence the result can be used as an extra primary vector to ensure that code combinations 
#' not suppressed according to `suppressedData` are forced not to be primary suppressed.
#'
#' @param x A (sparse) dummy matrix
#' @param crossTable crossTable generated by parent function
#' @param suppressedData A data frame or a list of data frames as output from \code{\link{GaussSuppressionFromData}}. I variable `suppressed` is not included. All rows are considered suppressed.
#' @param forcedData When `TRUE`, the suppressed coding is swapped. 
#' @param totCode A named list of totals codes   
#' 
#' @return Logical vector to be used as \code{\link{GaussSuppression}} input 
#' 
#' @export
#' 
#' 
PrimaryFromSuppressedData <- function(x, crossTable, suppressedData, forcedData = FALSE, totCode = FindTotCode2(x, crossTable), ...) {
  
  if (is.null(dim(suppressedData))) {  # list of several suppressedData
    primary <- rep(FALSE, nrow(crossTable))
    for (i in seq_along(suppressedData)) {
      primary <- primary | PrimaryFromSuppressedData(x = x, crossTable = crossTable, suppressedData = suppressedData[[i]], totCode = totCode)
    }
    return(primary)
  }
  
  crossTable_in_suppressedData <- names(crossTable) %in% names(suppressedData)
  
  namesIn <- names(crossTable)[crossTable_in_suppressedData]
  namesNotIn <- names(crossTable)[!crossTable_in_suppressedData]
  
  rows <- rep(TRUE, nrow(crossTable))
  
  for (i in seq_along(namesNotIn)) {
    rows <- rows & (crossTable[[namesNotIn[i]]] %in% totCode[[namesNotIn[i]]])
  }
  
  if ("suppressed" %in% names(suppressedData)) {
    if (forcedData) {
      suppressedData <- suppressedData[!suppressedData$suppressed, namesIn, drop = FALSE]
    } else {
      suppressedData <- suppressedData[suppressedData$suppressed, namesIn, drop = FALSE]
    }
  }
  
  ma <- Match(crossTable[rows, namesIn], suppressedData)
  
  rows[rows][is.na(ma)] <- FALSE
  rows
}

#' @rdname PrimaryFromSuppressedData
#' @export
ForcedFromSuppressedData <- function(..., forcedData = TRUE) {
  PrimaryFromSuppressedData(..., forcedData = forcedData)
}


#' @rdname PrimaryFromSuppressedData
#' @export
NotPrimaryFromSuppressedData <- function(..., forcedData = TRUE) {
  a <- PrimaryFromSuppressedData(..., forcedData = forcedData)
  a[a] <- NA
  a
}

  
FindTotCode2 <- function(x, crossTable) {   # other function SSBtools:::FindTotCode exist
  totCol <- FindTotCol(x)
  lapply(as.list(crossTable[totCol, ]), unique)
}


FindTotCol <- function(x) {  # based on SSBtools:::FindTotRow
  nr <- nrow(x)
  w1 <- which(colSums(x) == nr)
  if (length(w1)) {
    z <- x[, w1, drop = FALSE]^2
    w2 <- which(colSums(z) == nr)
    if (length(w2)) {
      return(w1[w2])
    }
  }
  w1
}
